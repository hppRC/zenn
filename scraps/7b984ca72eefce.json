{
  "title": "proc-macro-workshop/builder に取り組む",
  "closed": false,
  "archived": false,
  "created_at": "2021-03-17",
  "comments": [
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_updated_at": "2021-03-19",
      "body_markdown": "参考:\nhttps://github.com/dtolnay/proc-macro-workshop\nhttps://zenn.dev/magurotuna/articles/bab4db5999ebfa\n\nproc-macro-workshop/builderからやる、Builderパターンを実装するderiveマクロを作るやつ。\n\n各ステップごとのコードを残す、ポイントとかも書いたりするかもしれない。\nGitHubでcommit logを辿るよりも、zennで縦長にみた方がわかりやすい気がするので、後進のために残しておく。\n\n一応GitHubも貼っておく、commitは細かく切ったりしていないので注意。\n\nhttps://github.com/hppRC/proc-macro-workshop"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_updated_at": "2021-03-19",
      "body_markdown": "# 準備\n\nまずはこれらをインストールしないと始まらない。\n```bash\ncargo add syn quote proc_macro2  \n```\n\nnightlyを使うと、マクロについてのエラーメッセージをわかりやすくみることができるので、切り替えておくことを推奨。\n\n```bash\nrustup install nightly\n```\n\n以下のコマンドでテストを走らせる。\nテストしたいテストケースについて、事前に`tests/progress.rs`のコメントアウトを外しておく必要がある。\n\nマクロのバックトレースをみたい場合は、フラグを付け足してやる。\n`-Z macro-backtrace`はcargoのフラグではなく、rustcに渡されるべきフラグなので、コマンドの前に付け足しておく。\n\n```bash\ncargo test\n# または\nRUSTFLAGS=\"-Z macro-backtrace\" cargo +nightly test\n```\n\n他に、`cargo-expand`を入れておくと便利そう。\n```bash\ncargo install cargo-expand\n```\n\n`cargo-expand`を使う場合、`tests`ディレクトリのファイルを対象としたマクロの展開はできないみたいなので、`tests`ディレクトリをコピって`examples`ディレクトリを作り、以下のように叩くといい。\n\n\n```bash\nmkdir debug\ncargo expand --example 03-call-setters > debug/03-call-setters.rs \n```\n\n参考:\nhttps://users.rust-lang.org/t/how-to-run-cargo-expand-on-a-single-macro/31224"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_updated_at": "2021-03-17",
      "body_markdown": "# 01-parse.rs\n\n```rust:lib.rs\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: TokenStream) -> TokenStream {\n    let _ = input;\n\n    let expanded = quote! {};\n    // Hand the output tokens back to the compiler\n    TokenStream::from(expanded)\n}\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_markdown": "# 02-create-builder.rs\n\n```rust:lib.rs\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: TokenStream) -> TokenStream {\n    let _ = input;\n\n    let expanded = quote! {\n        pub struct CommandBuilder {\n            executable: Option<String>,\n            args: Option<Vec<String>>,\n            env: Option<Vec<String>>,\n            current_dir: Option<String>,\n        }\n\n        impl Command {\n            pub fn builder() -> CommandBuilder {\n                CommandBuilder {\n                    executable: None,\n                    args: None,\n                    env: None,\n                    current_dir: None,\n                }\n            }\n        }\n    };\n    // Hand the output tokens back to the compiler\n    TokenStream::from(expanded)\n}\n\n\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_markdown": "# 03-call-setters.rs\n\n```rust:lib.rs\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: TokenStream) -> TokenStream {\n    let _ = input;\n\n    let expanded = quote! {\n        pub struct CommandBuilder {\n            executable: Option<String>,\n            args: Option<Vec<String>>,\n            env: Option<Vec<String>>,\n            current_dir: Option<String>,\n        }\n\n        impl Command {\n            pub fn builder() -> CommandBuilder {\n                CommandBuilder {\n                    executable: None,\n                    args: None,\n                    env: None,\n                    current_dir: None,\n                }\n            }\n        }\n\n        impl CommandBuilder {\n            fn executable(&mut self, executable: String) -> &mut Self {\n                self.executable = Some(executable);\n                self\n            }\n            fn args(&mut self, args: Vec<String>) -> &mut Self {\n                self.args = Some(args);\n                self\n            }\n            fn env(&mut self, env: Vec<String>) -> &mut Self {\n                self.env = Some(env);\n                self\n            }\n            fn current_dir(&mut self, current_dir: String) -> &mut Self {\n                self.current_dir = Some(current_dir);\n                self\n            }\n        }\n    };\n    // Hand the output tokens back to the compiler\n    TokenStream::from(expanded)\n}\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_markdown": "# 04-call-build.rs\n\n```rust:lib.rs\nuse proc_macro::TokenStream;\nuse quote::quote;\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: TokenStream) -> TokenStream {\n    let _ = input;\n\n    let expanded = quote! {\n        pub struct CommandBuilder {\n            executable: Option<String>,\n            args: Option<Vec<String>>,\n            env: Option<Vec<String>>,\n            current_dir: Option<String>,\n        }\n\n        impl Command {\n            pub fn builder() -> CommandBuilder {\n                CommandBuilder {\n                    executable: None,\n                    args: None,\n                    env: None,\n                    current_dir: None,\n                }\n            }\n        }\n\n        impl CommandBuilder {\n            fn executable(&mut self, executable: String) -> &mut Self {\n                self.executable = Some(executable);\n                self\n            }\n            fn args(&mut self, args: Vec<String>) -> &mut Self {\n                self.args = Some(args);\n                self\n            }\n            fn env(&mut self, env: Vec<String>) -> &mut Self {\n                self.env = Some(env);\n                self\n            }\n            fn current_dir(&mut self, current_dir: String) -> &mut Self {\n                self.current_dir = Some(current_dir);\n                self\n            }\n\n            pub fn build(&mut self) -> Result<Command, Box<dyn std::error::Error>> {\n                if self.executable.is_none() || self.args.is_none() || self.env.is_none() || self.current_dir.is_none() {\n                    Err(\"Error occured!\".into())\n                } else {\n                    Ok(Command {\n                        executable: self.executable.clone().unwrap(),\n                        args: self.args.clone().unwrap(),\n                        env: self.env.clone().unwrap(),\n                        current_dir: self.current_dir.clone().unwrap(),\n                    })\n                }\n            }\n        }\n    };\n    // Hand the output tokens back to the compiler\n    TokenStream::from(expanded)\n}\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-17",
      "body_markdown": "# 05-method-chaining.rs\n\n変更なし"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-18",
      "body_markdown": "# 06-optional-field.rs\n\nこれに取り組む上で、ここまで書いてきたような構造体のフィールド名と型をハードコードするような書き方では対応できなくなるので、汎用的なderiveマクロとして使えるように書き直す。\n"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-18",
      "body_updated_at": "2021-03-18",
      "body_markdown": "# Update: 02-create-builder.rs\n\n```rust:lib.rs\nuse quote::{format_ident, quote};\nuse syn::{parse_macro_input, DeriveInput};\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n\n    let expanded = quote! {\n        pub struct #builder_name {}\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {}\n            }\n        }\n    };\n\n    proc_macro::TokenStream::from(expanded)\n}\n```\n\n",
      "children": [
        {
          "author": "hpp",
          "created_at": "2021-03-18",
          "body_updated_at": "2021-03-18",
          "body_markdown": "structの名前を使ってBuilder structの名前を作っている部分、`format!`マクロだと、マクロの展開時に以下のようになってしまうので不適。identifierではなく文字列として埋め込まれてしまう。\n\n```rust\nimpl Command {\n  pub fn builder() -> \"CommandBuilder\" {\n    \"CommnadBuilder\" {}\n  }\n}\n```\n\n正しくはこうなってほしい。\n\n```rust\nimpl Command {\n  pub fn builder() -> CommandBuilder {\n    CommnadBuilder {}\n  }\n}\n```"
        }
      ]
    },
    {
      "author": "hpp",
      "created_at": "2021-03-18",
      "body_markdown": "# Update: 03-call-setters.rs   \n\n```rust:lib.rs\nuse quote::{format_ident, quote};\nuse syn::{parse_macro_input, Data, DeriveInput, Fields, FieldsNamed};\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n    let fields = extract_struct_fields(&item.data);\n\n    let wrapped_fields_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        quote! {\n            #ident: Option<#ty>\n        }\n    });\n    let initial_fileds_stream_iter = fields.named.iter().map(|field| {\n        let ident = &field.ident;\n        quote! {\n            #ident: None\n        }\n    });\n    let builder_fields_setter_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        quote! {\n            fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                self.#ident = Some(#ident);\n                self\n            }\n        }\n    });\n\n    let expanded = quote! {\n        pub struct #builder_name {\n            #(#wrapped_fields_stream_iter),*\n        }\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {\n                    #(#initial_fileds_stream_iter),*\n                }\n            }\n        }\n\n        impl #builder_name {\n            #(#builder_fields_setter_stream_iter)*\n        }\n    };\n\n    // Hand the output tokens back to the compiler\n    proc_macro::TokenStream::from(expanded)\n}\n\nfn extract_struct_fields(data: &Data) -> &FieldsNamed {\n    match *data {\n        Data::Struct(ref data) => match data.fields {\n            Fields::Named(ref fields) => fields,\n            _ => panic!(\"invalid fields\"),\n        },\n        _ => panic!(\"invalid data\"),\n        // Data::Enum(_) => {}\n        // Data::Union(_) => {}\n    }\n}\n\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-18",
      "body_markdown": "# Update: 04-call-build.rs\n\n```rust:lib.rs\nuse quote::{format_ident, quote};\nuse syn::{parse_macro_input, Data, DeriveInput, Fields, FieldsNamed};\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n    let fields = extract_struct_fields(&item.data);\n\n    let wrapped_fields_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        quote! {\n            #ident: Option<#ty>\n        }\n    });\n    let initial_fileds_stream_iter = fields.named.iter().map(|field| {\n        let ident = &field.ident;\n        quote! {\n            #ident: None\n        }\n    });\n    let builder_fields_setter_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        quote! {\n            fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                self.#ident = Some(#ident);\n                self\n            }\n        }\n    });\n    let builder_build_stream_iter = fields.named.iter().map(|field| {\n        let ident = &field.ident;\n        quote! {\n            #ident: self.#ident.clone().unwrap()\n        }\n    });\n\n    let expanded = quote! {\n        pub struct #builder_name {\n            #(#wrapped_fields_stream_iter),*\n        }\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {\n                    #(#initial_fileds_stream_iter),*\n                }\n            }\n        }\n\n        impl #builder_name {\n            #(#builder_fields_setter_stream_iter)*\n\n            pub fn build(&mut self) -> Result<#struct_name, Box<dyn std::error::Error>> {\n                Ok(#struct_name {\n                    #(#builder_build_stream_iter),*\n                })\n            }\n        }\n    };\n\n    // Hand the output tokens back to the compiler\n    proc_macro::TokenStream::from(expanded)\n}\n\nfn extract_struct_fields(data: &Data) -> &FieldsNamed {\n    match *data {\n        Data::Struct(ref data) => match data.fields {\n            Fields::Named(ref fields) => fields,\n            _ => panic!(\"invalid fields\"),\n        },\n        _ => panic!(\"invalid data\"),\n        // Data::Enum(_) => {}\n        // Data::Union(_) => {}\n    }\n}\n\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-18",
      "body_markdown": "# 06-optional-field.rs\n\n```rust:lib.rs\nuse quote::{format_ident, quote};\nuse syn::{\n    parse_macro_input, Data, DeriveInput, Fields, FieldsNamed, GenericArgument, Path,\n    PathArguments, PathSegment, Type, TypePath,\n};\n\n#[proc_macro_derive(Builder)]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n    let fields = extract_struct_fields(&item.data);\n\n    let wrapped_fields_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        if is_option_type(&ty) {\n            quote! {\n                #ident: #ty\n            }\n        } else {\n            quote! {\n                #ident: Option<#ty>\n            }\n        }\n    });\n\n    let initial_fileds_stream_iter = fields.named.iter().map(|field| {\n        let ident = &field.ident;\n        quote! {\n            #ident: None\n        }\n    });\n\n    let builder_fields_setter_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        if is_option_type(&ty) {\n            let inner_type = option_inner_type(&ty);\n            quote! {\n                fn #ident(&mut self, #ident: #inner_type) -> &mut Self {\n                    self.#ident = Some(#ident);\n                    self\n                }\n            }\n        } else {\n            quote! {\n                fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                    self.#ident = Some(#ident);\n                    self\n                }\n            }\n        }\n    });\n\n    let builder_build_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: self.#ident.clone()\n            }\n        } else {\n            quote! {\n                #ident: self.#ident.clone().unwrap()\n            }\n        }\n    });\n\n    let expanded = quote! {\n        pub struct #builder_name {\n            #(#wrapped_fields_stream_iter),*\n        }\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {\n                    #(#initial_fileds_stream_iter),*\n                }\n            }\n        }\n\n        impl #builder_name {\n            #(#builder_fields_setter_stream_iter)*\n\n            pub fn build(&mut self) -> Result<#struct_name, Box<dyn std::error::Error>> {\n                Ok(#struct_name {\n                    #(#builder_build_stream_iter),*\n                })\n            }\n        }\n    };\n\n    // Hand the output tokens back to the compiler\n    proc_macro::TokenStream::from(expanded)\n}\n\nfn extract_struct_fields(data: &Data) -> &FieldsNamed {\n    match *data {\n        Data::Struct(ref data) => match data.fields {\n            Fields::Named(ref fields) => fields,\n            _ => panic!(\"invalid fields\"),\n        },\n        _ => panic!(\"invalid data\"),\n        // Data::Enum(_) => {}\n        // Data::Union(_) => {}\n    }\n}\n\nfn is_option_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        Some(path_seg) => path_seg.ident == \"Option\",\n        None => false,\n    }\n}\n\nfn option_inner_type(ty: &Type) -> &GenericArgument {\n    match last_path_segment(&ty) {\n        Some(PathSegment {\n            ident: _,\n            arguments: PathArguments::AngleBracketed(ref gen_arg),\n        }) => gen_arg.args.first(),\n        _ => None,\n    }\n    .expect(\"invalid option type\")\n}\n\nfn last_path_segment(ty: &Type) -> Option<&PathSegment> {\n    match ty {\n        &Type::Path(TypePath {\n            qself: None,\n            path:\n                Path {\n                    segments: ref seg,\n                    leading_colon: _,\n                },\n        }) => seg.last(),\n        _ => None,\n    }\n}\n\n```"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-19",
      "body_markdown": "# 07-repeated-field.rs\n\n```rust:lib.rs\nuse quote::{format_ident, quote};\nuse syn::{\n    parse_macro_input, Attribute, Data, DeriveInput, Fields, FieldsNamed, GenericArgument, Lit,\n    Meta, MetaList, MetaNameValue, NestedMeta, Path, PathArguments, PathSegment, Type, TypePath,\n};\n\n#[proc_macro_derive(Builder, attributes(builder))]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n    let fields = extract_struct_fields(&item.data);\n\n    let wrapped_fields_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: #ty\n            }\n        } else {\n            quote! {\n                #ident: Option<#ty>\n            }\n        }\n    });\n\n    let initial_fileds_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        let attrs = &field.attrs;\n        let each_string_literal = extract_string_literal_of_attr_each(&attrs);\n\n        if is_vec_type(&ty) && each_string_literal.is_some() {\n            quote! {\n                #ident: Some(vec![])\n            }\n        } else {\n            quote! {\n                #ident: None\n            }\n        }\n    });\n\n    let builder_fields_setter_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        let attrs = &field.attrs;\n        let each_string_literal = extract_string_literal_of_attr_each(&attrs);\n\n        if is_vec_type(&ty) && each_string_literal.is_some() {\n            let inner_type = extract_inner_type(&ty);\n            let lit = each_string_literal.unwrap();\n            let lit_ident = format_ident!(\"{}\", lit);\n\n            if lit == ident.clone().unwrap().to_string() {\n                let ref_ident = format_ident!(\"ref_{}\", lit);\n                quote! {\n                    fn #ident(&mut self, #lit_ident: #inner_type) -> &mut Self {\n                        if let Some(ref mut #ref_ident) = self.#ident {\n                            #ref_ident.push(#lit_ident);\n                        } else {\n                            self.#ident = Some(vec![#lit_ident]);\n                        };\n                        self\n                    }\n                }\n            } else {\n                quote! {\n                    fn #lit_ident(&mut self, #lit_ident: #inner_type) -> &mut Self {\n                        if let Some(ref mut #ident) = self.#ident {\n                            #ident.push(#lit_ident);\n                        } else {\n                            self.#ident = Some(vec![#lit_ident]);\n                        };\n                        self\n                    }\n\n                    fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                        self.#ident = Some(#ident);\n                        self\n                    }\n                }\n            }\n        } else {\n            if is_option_type(&ty) {\n                let inner_type = extract_inner_type(&ty);\n                quote! {\n                    fn #ident(&mut self, #ident: #inner_type) -> &mut Self {\n                        self.#ident = Some(#ident);\n                        self\n                    }\n                }\n            } else {\n                quote! {\n                    fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                        self.#ident = Some(#ident);\n                        self\n                    }\n                }\n            }\n        }\n    });\n\n    let builder_build_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: self.#ident.clone()\n            }\n        } else {\n            quote! {\n                #ident: self.#ident.clone().unwrap()\n            }\n        }\n    });\n\n    let expanded = quote! {\n        pub struct #builder_name {\n            #(#wrapped_fields_stream_iter),*\n        }\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {\n                    #(#initial_fileds_stream_iter),*\n                }\n            }\n        }\n\n        impl #builder_name {\n            #(#builder_fields_setter_stream_iter)*\n\n            pub fn build(&mut self) -> Result<#struct_name, Box<dyn std::error::Error>> {\n                Ok(#struct_name {\n                    #(#builder_build_stream_iter),*\n                })\n            }\n        }\n    };\n\n    // Hand the output tokens back to the compiler\n    proc_macro::TokenStream::from(expanded)\n}\n\nfn extract_struct_fields(data: &Data) -> &FieldsNamed {\n    match *data {\n        Data::Struct(ref data) => match data.fields {\n            Fields::Named(ref fields) => fields,\n            _ => panic!(\"invalid fields\"),\n        },\n        _ => panic!(\"invalid data\"),\n        // Data::Enum(_) => {}\n        // Data::Union(_) => {}\n    }\n}\n\nfn is_option_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        Some(path_seg) => path_seg.ident == \"Option\",\n        None => false,\n    }\n}\n\nfn is_vec_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        Some(path_seg) => path_seg.ident == \"Vec\",\n        None => false,\n    }\n}\n\nfn extract_inner_type(ty: &Type) -> &GenericArgument {\n    match last_path_segment(&ty) {\n        Some(PathSegment {\n            ident: _,\n            arguments: PathArguments::AngleBracketed(ref gen_arg),\n        }) => gen_arg.args.first(),\n        _ => None,\n    }\n    .expect(\"invalid option type\")\n}\n\nfn last_path_segment(ty: &Type) -> Option<&PathSegment> {\n    match ty {\n        &Type::Path(TypePath {\n            qself: None,\n            path:\n                Path {\n                    segments: ref seg,\n                    leading_colon: _,\n                },\n        }) => seg.last(),\n        _ => None,\n    }\n}\n\nfn extract_string_literal_of_attr_each(attrs: &[Attribute]) -> Option<String> {\n    attrs.iter().find_map(|attr| match attr.parse_meta() {\n        Ok(Meta::List(MetaList {\n            ref path,\n            paren_token: _,\n            ref nested,\n        })) => {\n            (path.get_ident()? == \"builder\").then(|| ())?;\n\n            if let NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n                path,\n                eq_token: _,\n                lit: Lit::Str(ref litstr),\n            })) = nested.first()?\n            {\n                if path.get_ident()?.to_string() == \"each\" {\n                    Some(litstr.value())\n                } else {\n                    None\n                }\n            } else {\n                None\n            }\n        }\n        _ => None,\n    })\n}\n\n```",
      "children": [
        {
          "author": "hpp",
          "created_at": "2021-03-19",
          "body_markdown": "頑張って場合分けを書くのと、`each`アトリビュートが有効なフィールドについてはデフォルト値をセットしておくのがポイント。"
        }
      ]
    },
    {
      "author": "hpp",
      "created_at": "2021-03-19",
      "body_markdown": "# 08-unrecognized-attribute.rs\n\n```rust:lib.rs\n\nuse quote::{format_ident, quote};\nuse syn::{\n    parse_macro_input, Attribute, Data, DeriveInput, Error, Fields, FieldsNamed, GenericArgument,\n    Lit, Meta, MetaList, MetaNameValue, NestedMeta, Path, PathArguments, PathSegment, Type,\n    TypePath,\n};\n\n#[proc_macro_derive(Builder, attributes(builder))]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n    let fields = extract_struct_fields(&item.data);\n\n    let wrapped_fields_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: #ty\n            }\n        } else {\n            quote! {\n                #ident: Option<#ty>\n            }\n        }\n    });\n\n    let initial_fileds_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        let attrs = &field.attrs;\n        let attr_each = parse_attr_each(&attrs);\n\n        if is_vec_type(&ty) && attr_each.is_some() {\n            quote! {\n                #ident: Some(vec![])\n            }\n        } else {\n            quote! {\n                #ident: None\n            }\n        }\n    });\n\n    let builder_fields_setter_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        let attrs = &field.attrs;\n        let attr_each = parse_attr_each(&attrs);\n\n        if is_vec_type(&ty) && attr_each.is_some() {\n            match attr_each {\n                Some(AttrParseResult::InvalidKey(meta)) => {\n                    return Error::new_spanned(meta, \"expected `builder(each = \\\"...\\\")`\")\n                        .to_compile_error()\n                }\n                Some(AttrParseResult::Value(lit)) => {\n                    let inner_type = extract_inner_type(&ty);\n                    let lit_ident = format_ident!(\"{}\", lit);\n\n                    if lit == ident.clone().unwrap().to_string() {\n                        let ref_ident = format_ident!(\"ref_{}\", lit);\n                        quote! {\n                            fn #ident(&mut self, #lit_ident: #inner_type) -> &mut Self {\n                                if let Some(ref mut #ref_ident) = self.#ident {\n                                    #ref_ident.push(#lit_ident);\n                                } else {\n                                    self.#ident = Some(vec![#lit_ident]);\n                                };\n                                self\n                            }\n                        }\n                    } else {\n                        quote! {\n                            fn #lit_ident(&mut self, #lit_ident: #inner_type) -> &mut Self {\n                                if let Some(ref mut #ident) = self.#ident {\n                                    #ident.push(#lit_ident);\n                                } else {\n                                    self.#ident = Some(vec![#lit_ident]);\n                                };\n                                self\n                            }\n\n                            fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                                self.#ident = Some(#ident);\n                                self\n                            }\n                        }\n                    }\n                }\n                None => unreachable!(),\n            }\n        } else {\n            if is_option_type(&ty) {\n                let inner_type = extract_inner_type(&ty);\n                quote! {\n                    fn #ident(&mut self, #ident: #inner_type) -> &mut Self {\n                        self.#ident = Some(#ident);\n                        self\n                    }\n                }\n            } else {\n                quote! {\n                    fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                        self.#ident = Some(#ident);\n                        self\n                    }\n                }\n            }\n        }\n    });\n\n    let builder_build_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: self.#ident.clone()\n            }\n        } else {\n            quote! {\n                #ident: self.#ident.clone().unwrap()\n            }\n        }\n    });\n\n    let expanded = quote! {\n        pub struct #builder_name {\n            #(#wrapped_fields_stream_iter),*\n        }\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {\n                    #(#initial_fileds_stream_iter),*\n                }\n            }\n        }\n\n        impl #builder_name {\n            #(#builder_fields_setter_stream_iter)*\n\n            pub fn build(&mut self) -> Result<#struct_name, Box<dyn std::error::Error>> {\n                Ok(#struct_name {\n                    #(#builder_build_stream_iter),*\n                })\n            }\n        }\n    };\n\n    // Hand the output tokens back to the compiler\n    proc_macro::TokenStream::from(expanded)\n}\n\nfn extract_struct_fields(data: &Data) -> &FieldsNamed {\n    match *data {\n        Data::Struct(ref data) => match data.fields {\n            Fields::Named(ref fields) => fields,\n            _ => panic!(\"invalid fields\"),\n        },\n        _ => panic!(\"invalid data\"),\n        // Data::Enum(_) => {}\n        // Data::Union(_) => {}\n    }\n}\n\nfn is_option_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        Some(path_seg) => path_seg.ident == \"Option\",\n        None => false,\n    }\n}\n\nfn is_vec_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        Some(path_seg) => path_seg.ident == \"Vec\",\n        None => false,\n    }\n}\n\nfn extract_inner_type(ty: &Type) -> &GenericArgument {\n    match last_path_segment(&ty) {\n        Some(PathSegment {\n            ident: _,\n            arguments: PathArguments::AngleBracketed(ref gen_arg),\n        }) => gen_arg.args.first(),\n        _ => None,\n    }\n    .expect(\"invalid option type\")\n}\n\nfn last_path_segment(ty: &Type) -> Option<&PathSegment> {\n    match ty {\n        &Type::Path(TypePath {\n            qself: None,\n            path:\n                Path {\n                    segments: ref seg,\n                    leading_colon: _,\n                },\n        }) => seg.last(),\n        _ => None,\n    }\n}\n\nenum AttrParseResult {\n    Value(String),\n    InvalidKey(Meta),\n}\n\nfn parse_attr_each(attrs: &[Attribute]) -> Option<AttrParseResult> {\n    attrs.iter().find_map(|attr| match attr.parse_meta() {\n        Ok(meta) => match meta {\n            Meta::List(MetaList {\n                ref path,\n                paren_token: _,\n                ref nested,\n            }) => {\n                (path.get_ident()? == \"builder\").then(|| ())?;\n\n                if let NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n                    path,\n                    eq_token: _,\n                    lit: Lit::Str(ref litstr),\n                })) = nested.first()?\n                {\n                    if path.get_ident()?.to_string() == \"each\" {\n                        Some(AttrParseResult::Value(litstr.value()))\n                    } else {\n                        Some(AttrParseResult::InvalidKey(meta))\n                    }\n                } else {\n                    None\n                }\n            }\n            _ => None,\n        },\n        _ => None,\n    })\n}\n\n```",
      "children": [
        {
          "author": "hpp",
          "created_at": "2021-03-19",
          "body_markdown": "結構適当にやっている、本当は最初にバリデーションを一括でやった方がいい気がする。"
        }
      ]
    },
    {
      "author": "hpp",
      "created_at": "2021-03-19",
      "body_markdown": "# 09-redefined-prelude-types.rs\n\n```rust:lib.rs\n\nuse quote::{format_ident, quote};\nuse syn::{\n    parse_macro_input, Attribute, Data, DeriveInput, Error, Fields, FieldsNamed, GenericArgument,\n    Lit, Meta, MetaList, MetaNameValue, NestedMeta, Path, PathArguments, PathSegment, Type,\n    TypePath,\n};\n\n#[proc_macro_derive(Builder, attributes(builder))]\npub fn derive(input: proc_macro::TokenStream) -> proc_macro::TokenStream {\n    // Parse the input tokens into a syntax tree\n    let item = parse_macro_input!(input as DeriveInput);\n    let struct_name = item.ident;\n    let builder_name = format_ident!(\"{}Builder\", struct_name);\n    let fields = extract_struct_fields(&item.data);\n\n    let wrapped_fields_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: #ty\n            }\n        } else {\n            quote! {\n                #ident: std::option::Option<#ty>\n            }\n        }\n    });\n\n    let initial_fileds_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        let attrs = &field.attrs;\n        let attr_each = parse_attr_each(&attrs);\n\n        if is_vec_type(&ty) && attr_each.is_some() {\n            quote! {\n                #ident: std::option::Option::Some(vec![])\n            }\n        } else {\n            quote! {\n                #ident: std::option::Option::None\n            }\n        }\n    });\n\n    let builder_fields_setter_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n        let attrs = &field.attrs;\n        let attr_each = parse_attr_each(&attrs);\n\n        if is_vec_type(&ty) && attr_each.is_some() {\n            match attr_each {\n                std::option::Option::Some(AttrParseResult::InvalidKey(meta)) => {\n                    return Error::new_spanned(meta, \"expected `builder(each = \\\"...\\\")`\")\n                        .to_compile_error()\n                }\n                std::option::Option::Some(AttrParseResult::Value(lit)) => {\n                    let inner_type = extract_inner_type(&ty);\n                    let lit_ident = format_ident!(\"{}\", lit);\n\n                    if lit == ident.clone().unwrap().to_string() {\n                        let ref_ident = format_ident!(\"ref_{}\", lit);\n                        quote! {\n                            fn #ident(&mut self, #lit_ident: #inner_type) -> &mut Self {\n                                if let std::option::Option::Some(ref mut #ref_ident) = self.#ident {\n                                    #ref_ident.push(#lit_ident);\n                                } else {\n                                    self.#ident = std::option::Option::Some(vec![#lit_ident]);\n                                };\n                                self\n                            }\n                        }\n                    } else {\n                        quote! {\n                            fn #lit_ident(&mut self, #lit_ident: #inner_type) -> &mut Self {\n                                if let std::option::Option::Some(ref mut #ident) = self.#ident {\n                                    #ident.push(#lit_ident);\n                                } else {\n                                    self.#ident = std::option::Option::Some(vec![#lit_ident]);\n                                };\n                                self\n                            }\n\n                            fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                                self.#ident = std::option::Option::Some(#ident);\n                                self\n                            }\n                        }\n                    }\n                }\n                std::option::Option::None => unreachable!(),\n            }\n        } else {\n            if is_option_type(&ty) {\n                let inner_type = extract_inner_type(&ty);\n                quote! {\n                    fn #ident(&mut self, #ident: #inner_type) -> &mut Self {\n                        self.#ident = std::option::Option::Some(#ident);\n                        self\n                    }\n                }\n            } else {\n                quote! {\n                    fn #ident(&mut self, #ident: #ty) -> &mut Self {\n                        self.#ident = std::option::Option::Some(#ident);\n                        self\n                    }\n                }\n            }\n        }\n    });\n\n    let builder_build_stream_iter = fields.named.iter().map(|field| {\n        let ty = &field.ty;\n        let ident = &field.ident;\n\n        if is_option_type(&ty) {\n            quote! {\n                #ident: self.#ident.clone()\n            }\n        } else {\n            quote! {\n                #ident: self.#ident.clone().unwrap()\n            }\n        }\n    });\n\n    let expanded = quote! {\n        pub struct #builder_name {\n            #(#wrapped_fields_stream_iter),*\n        }\n\n        impl #struct_name {\n            pub fn builder() -> #builder_name {\n                #builder_name {\n                    #(#initial_fileds_stream_iter),*\n                }\n            }\n        }\n\n        impl #builder_name {\n            #(#builder_fields_setter_stream_iter)*\n\n            pub fn build(&mut self) -> std::result::Result<#struct_name, std::boxed::Box<dyn std::error::Error>> {\n                Ok(#struct_name {\n                    #(#builder_build_stream_iter),*\n                })\n            }\n        }\n    };\n\n    // Hand the output tokens back to the compiler\n    proc_macro::TokenStream::from(expanded)\n}\n\nfn extract_struct_fields(data: &Data) -> &FieldsNamed {\n    match *data {\n        Data::Struct(ref data) => match data.fields {\n            Fields::Named(ref fields) => fields,\n            _ => panic!(\"invalid fields\"),\n        },\n        _ => panic!(\"invalid data\"),\n        // Data::Enum(_) => {}\n        // Data::Union(_) => {}\n    }\n}\n\nfn is_option_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        std::option::Option::Some(path_seg) => path_seg.ident == \"Option\",\n        std::option::Option::None => false,\n    }\n}\n\nfn is_vec_type(ty: &Type) -> bool {\n    match last_path_segment(&ty) {\n        std::option::Option::Some(path_seg) => path_seg.ident == \"Vec\",\n        std::option::Option::None => false,\n    }\n}\n\nfn extract_inner_type(ty: &Type) -> &GenericArgument {\n    match last_path_segment(&ty) {\n        std::option::Option::Some(PathSegment {\n            ident: _,\n            arguments: PathArguments::AngleBracketed(ref gen_arg),\n        }) => gen_arg.args.first(),\n        _ => std::option::Option::None,\n    }\n    .expect(\"invalid option type\")\n}\n\nfn last_path_segment(ty: &Type) -> std::option::Option<&PathSegment> {\n    match ty {\n        &Type::Path(TypePath {\n            qself: std::option::Option::None,\n            path:\n                Path {\n                    segments: ref seg,\n                    leading_colon: _,\n                },\n        }) => seg.last(),\n        _ => std::option::Option::None,\n    }\n}\n\nenum AttrParseResult {\n    Value(String),\n    InvalidKey(Meta),\n}\n\nfn parse_attr_each(attrs: &[Attribute]) -> std::option::Option<AttrParseResult> {\n    attrs.iter().find_map(|attr| match attr.parse_meta() {\n        Ok(meta) => match meta {\n            Meta::List(MetaList {\n                ref path,\n                paren_token: _,\n                ref nested,\n            }) => {\n                (path.get_ident()? == \"builder\").then(|| ())?;\n\n                if let NestedMeta::Meta(Meta::NameValue(MetaNameValue {\n                    path,\n                    eq_token: _,\n                    lit: Lit::Str(ref litstr),\n                })) = nested.first()?\n                {\n                    if path.get_ident()?.to_string() == \"each\" {\n                        std::option::Option::Some(AttrParseResult::Value(litstr.value()))\n                    } else {\n                        std::option::Option::Some(AttrParseResult::InvalidKey(meta))\n                    }\n                } else {\n                    std::option::Option::None\n                }\n            }\n            _ => std::option::Option::None,\n        },\n        _ => std::option::Option::None,\n    })\n}\n\n```",
      "children": [
        {
          "author": "hpp",
          "created_at": "2021-03-19",
          "body_markdown": "比較的安全なRustのマクロだけど、流石に名前空間とかは気を付けなきゃいけないみたい。"
        }
      ]
    },
    {
      "author": "hpp",
      "created_at": "2021-03-19",
      "body_markdown": "全体を通して、attributeさえなければ結構綺麗に書けるなという印象。\nattributeももっと上手くハンドリングできるような気がするが、いろいろなケースを処理しようとするとどうしても本質的な複雑さを隠せない感じになる。"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-21",
      "body_markdown": "attributeについては、処理を簡単にするためのcrateがある。\nそれが [darling](https://qiita.com/yagince/items/546d86588aaa3fdb3c94)。\n結構簡潔にかけそうだったので、書き直してみてもいいかもしれない。\n\n参考:\nhttps://qiita.com/yagince/items/546d86588aaa3fdb3c94"
    },
    {
      "author": "hpp",
      "created_at": "2021-03-22",
      "body_markdown": "synはデフォルトだと`dbg!`マクロが使えないので、\n```toml:Cargo.toml\n[dependencies]\nkuon = \"0.0.22\"\nproc-macro2 = \"1.0.24\"\nquote = \"1.0.9\"\nsyn = {version = \"1.0.64\", features = [\"extra-traits\"]}\n```\nとして、`Debug`をimplしてあげるといい。"
    }
  ]
}